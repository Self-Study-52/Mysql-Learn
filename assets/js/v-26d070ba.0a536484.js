"use strict";(self.webpackChunkMysql_Learn=self.webpackChunkMysql_Learn||[]).push([[619],{156:(e,s,t)=>{t.r(s),t.d(s,{data:()=>a});const a={key:"v-26d070ba",path:"/guide/%E3%80%8AMysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5.html",title:"第十八章：数据插入",lang:"en-US",frontmatter:{title:"第十八章：数据插入",lang:"en-US"},excerpt:"",headers:[{level:2,title:"插入完整行",slug:"插入完整行",children:[]},{level:2,title:"插入多行",slug:"插入多行",children:[]},{level:2,title:"插入检索出的数据",slug:"插入检索出的数据",children:[]}],filePathRelative:"guide/《Mysql必知必会》/第十八章：数据插入.md",git:{updatedTime:1635847604e3,contributors:[{name:"Sue-52",email:"1219243947@qq.com",commits:1}]}}},2851:(e,s,t)=>{t.r(s),t.d(s,{default:()=>u});const a=(0,t(6252).uE)('<h1 id="第十八章-数据插入" tabindex="-1"><a class="header-anchor" href="#第十八章-数据插入" aria-hidden="true">#</a> 第十八章：数据插入</h1><p><code>INSERT</code> 是用来插入（或添加）行到数据库表的。插入可以用几种方式使用：</p><ul><li>插入完整的行；</li><li>插入行的一部分；</li><li>插入多行；</li><li>插入某些查询的结果。</li></ul><h2 id="插入完整行" tabindex="-1"><a class="header-anchor" href="#插入完整行" aria-hidden="true">#</a> 插入完整行</h2><p>以下为向MySQL数据表插入数据通用的 INSERT INTO SQL语法：</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>INSERT INTO table_name ( field1, field2,...fieldN )\n                       VALUES\n                       ( value1, value2,...valueN );\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><hr><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>INSERT INTO customers \nVALUES (NULL,&quot;Pep E. LaPew&quot;,&quot;100 Main Street&quot;,&quot;Los Angeles&quot;,&quot;CA&quot;,&quot;90046&quot;,&quot;USA&quot;,NULL,NULL);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292228373.png" alt="image-20211022200428958"></p><p>虽然这种语法很简单，但并不安全，应该尽量避免使用。上面的SQL语句高度依赖于表中列的定义次序，并且还依赖于其次序容易获得的信息。即使可得到这种次序信息，也不能保证下一次表结构变动后各个列保持完全相同的次序。因此，编写依赖于特定列次序的SQL语句是很不安全的。如果这样做，有时难免会出问题。</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>INSERT INTO customers(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)\nVALUES (NULL,&quot;Pep E. LaPew&quot;,&quot;100 Main Street&quot;,&quot;Los Angeles&quot;,&quot;CA&quot;,&quot;900467&quot;,&quot;USA&quot;,NULL,NULL);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292228374.png" alt="image-20211022201039908"></p><blockquote><p><strong>总是使用列的列表</strong> 一般不要使用没有明确给出列的列表的INSERT语句。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化。</p></blockquote><blockquote><p><strong>仔细地给出值</strong> 不管使用哪种INSERT语法，都必须给出VALUES的正确数目。如果不提供列名，则必须给每个表列提供一个值。如果提供列名，则必须对每个列出的列给出一个值。如果不这样，将产生一条错误消息，相应的行插入不成功。</p></blockquote><p>如果表的定义允许，则可以在INSERT操作中省略某些列。省略的列必须满足以下某个条件。</p><ul><li>该列定义为允许NULL值（无值或空值）。</li><li>在表定义中给出默认值。这表示如果不给出值，将使用默认值。</li></ul><p>如果对表中不允许NULL值且没有默认值的列不给出值，则MySQL将产生一条错误消息，并且相应的行插入不成功。</p><p><strong>提高整体性能</strong>:数据库经常被多个客户访问，对处理什么请求以及用什么次序处理进行管理是MySQL的任务。INSERT操作可能很耗时（特别是有很多索引需要更新时），而且它可能降低等待处理的SELECT语句的性能。</p><p>如果数据检索是最重要的（通常是这样），则你可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>INSERT LOW PRIORITY INTO...\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="插入多行" tabindex="-1"><a class="header-anchor" href="#插入多行" aria-hidden="true">#</a> 插入多行</h2><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>INSERT INTO \ncustomers(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)\nVALUES \n(NULL,&quot;Pep E. LaPew&quot;,&quot;100 Main Street&quot;,&quot;Los Angeles&quot;,&quot;CA&quot;,&quot;900467&quot;,&quot;USA&quot;,NULL,NULL),\n(NULL,&quot;Pep A. LaPew&quot;,&quot;10 Main Street&quot;,&quot;Los Angeles&quot;,&quot;CA&quot;,&quot;900437&quot;,&quot;USA&quot;,NULL,NULL),\n(NULL,&quot;Pep B. LaPew&quot;,&quot;2100 Main Street&quot;,&quot;Los Angeles&quot;,&quot;CA&quot;,&quot;900457&quot;,&quot;USA&quot;,NULL,NULL)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292228375.png" alt="image-20211022201714634"></p><p><strong>以其中单条INSERT语句有多组值，每组值用一对圆括号括起来，用逗号分隔。</strong></p><p>提高INSERT的性能:此技术可以提高数据库处理的性能，因为MySQL用单条INSERT语句处理多个插入比使用多条INSERT语句快。</p><h2 id="插入检索出的数据" tabindex="-1"><a class="header-anchor" href="#插入检索出的数据" aria-hidden="true">#</a> 插入检索出的数据</h2><p>INSERT一般用来给表插入一个指定列值的行。但是，INSERT还存在另一种形式，可以利用它将一条SELECT语句的结果插入表中。这就是所谓的INSERT SELECT，顾名思义，它是由一条INSERT语句和一条SELECT语句组成的。</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>INSERT INTO custnew (\ncust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country\n) SELECT cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country\nFROM customers;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292228376.png" alt="image-20211022202837263"></p><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292228377.png" alt="image-20211022202911287"></p><p>INSERT SELECT中SELECT语句可包含WHERE子句以过滤插入的数据。</p>',31),n={},u=(0,t(3744).Z)(n,[["render",function(e,s){return a}]])},3744:(e,s)=>{s.Z=(e,s)=>{const t=e.__vccOpts||e;for(const[e,a]of s)t[e]=a;return t}}}]);