"use strict";(self.webpackChunkMysql_Learn=self.webpackChunkMysql_Learn||[]).push([[853],{5670:(e,s,n)=>{n.r(s),n.d(s,{data:()=>r});const r={key:"v-715bcc9c",path:"/guide/%E3%80%8AMysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E8%81%94%E7%BB%93%E8%A1%A8.html",title:"第十三章：联结表",lang:"en-US",frontmatter:{title:"第十三章：联结表",lang:"en-US"},excerpt:"",headers:[{level:2,title:"关系表",slug:"关系表",children:[]},{level:2,title:"为什么使用联结",slug:"为什么使用联结",children:[]},{level:2,title:"创建联结（⭐）",slug:"创建联结-⭐",children:[]},{level:2,title:"WHERE 语句的作用",slug:"where-语句的作用",children:[]},{level:2,title:"内部联结",slug:"内部联结",children:[]},{level:2,title:"联结多个表",slug:"联结多个表",children:[]}],filePathRelative:"guide/《Mysql必知必会》/第十四章：联结表.md",git:{updatedTime:1635847604e3,contributors:[{name:"Sue-52",email:"1219243947@qq.com",commits:1}]}}},3998:(e,s,n)=>{n.r(s),n.d(s,{default:()=>t});const r=(0,n(6252).uE)('<h1 id="第十三章-联结表" tabindex="-1"><a class="header-anchor" href="#第十三章-联结表" aria-hidden="true">#</a> 第十三章：联结表</h1><p>SQL最强大的功能之一就是能在数据检索查询的执行中联结（join）表。联结是利用SQL的SELECT能执行的最重要的操作。</p><p>在能够有效地使用联结前，必须了解关系表以及关系数据库设计的一些基础知识。</p><h2 id="关系表" tabindex="-1"><a class="header-anchor" href="#关系表" aria-hidden="true">#</a> 关系表</h2><p>假如有一个包含产品目录的数据库表，其中每种类别的物品占一行。对于每种物品要存储的信息包括产品描述和价格，以及生产该产品的供应商信息。</p><p>现在，假如有由同一供应商生产的多种物品，那么在何处存储供应商信息（如，供应商名、地址、联系方法等）呢？将这些数据与产品信息分开存储的理由如下。</p><ul><li>因为同一供应商生产的每个产品的供应商信息都是相同的，对每个产品重复此信息既浪费时间又浪费存储空间。</li><li>如果供应商信息改变（例如，供应商搬家或电话号码变动），只需改动一次即可。</li><li>如果有重复数据（即每种产品都存储供应商信息），很难保证每次输入该数据的方式都相同。不一致的数据在报表中很难利用。</li></ul><p>关键是，相同数据出现多次决不是一件好事，此因素是关系数据库设计的基础。</p><p>关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系（relational））互相关联。</p><p>在这个例子中，可建立两个表，一个存储供应商信息，另一个存储产品信息。vendors表包含所有供应商信息，每个供应商占一行，每个供应商具有唯一的标识。此标识称为主键（primary key），可以是供应商ID或任何其他唯一值。</p><p>products表只存储产品信息，它除了存储供应商ID（vendors表的主键）外不存储其他供应商信息。vendors表的主键又叫作products的外键，它将vendors表与products表关联，利用供应商ID能从vendors表中找出相应供应商的详细信息。</p><p><strong>外键（foreign key）</strong> 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p><p>好处：</p><ul><li>供应商信息不重复，从而不浪费时间和空间；</li><li>如果供应商信息变动，可以只更新vendors表中的单个记录，相关表中的数据不用改动；</li><li>由于数据无重复，显然数据是一致的，这使得处理数据更简单。</li></ul><p><strong>可伸缩性（scale）</strong> 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好（scale well）。</p><h2 id="为什么使用联结" tabindex="-1"><a class="header-anchor" href="#为什么使用联结" aria-hidden="true">#</a> 为什么使用联结</h2><p>分解数据为多个表能更有效地存储，更方便地处理，并且具有更大的可伸缩性。但这些好处是有代价的。</p><p>如果数据存储在多个表中，怎样用单条SELECT语句检索出数据？</p><p>答案是使用联结。简单地说，联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</p><h2 id="创建联结-⭐" tabindex="-1"><a class="header-anchor" href="#创建联结-⭐" aria-hidden="true">#</a> 创建联结（⭐）</h2><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>SELECT vend_name AS &quot;供应商&quot;,prod_name AS &quot;商品名&quot;,prod_price AS &quot;商品价格&quot;\nFROM vendors, products\nWHERE vendors.vend_id = products.vend_id \nORDER BY vend_name,prod_name\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292229433.png" alt="image-20211020180742393"></p><p>可以看到要匹配的两个列以 vendors.vend_id 和 products. vend_id指定。这里需要这种完全限定列名，因为如果只给出vend_id， 则MySQL不知道指的是哪一个（它们有两个，每个表中一个）。</p><blockquote><p><strong>完全限定列名</strong>：在引用的列可能出现二义性时，必须使用完全限定列名（用一个点分隔的表名和列名）。如果引用一个没有用表名限制的具有二义性的列名，MySQL将返回错误。</p></blockquote><h2 id="where-语句的作用" tabindex="-1"><a class="header-anchor" href="#where-语句的作用" aria-hidden="true">#</a> WHERE 语句的作用</h2><p>上文我们使用 <code>WHERE</code> 关键字将两个表之间创建了联结，WHERE子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行。</p><p>如果没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起，会造成笛卡尔积。</p><p><strong>笛卡儿积（cartesian product）</strong> 由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p><p><strong>不要忘了WHERE子句</strong> 应该保证所有联结都有WHERE子句，否则MySQL将返回比想要的数据多得多的数据。同理，应该保证WHERE子句的正确性。不正确的过滤条件将导致MySQL返回不正确的数据。</p><p><strong>叉联结</strong> 有时我们会听到返回称为叉联结（cross join）的笛卡儿积的联结类型。</p><h2 id="内部联结" tabindex="-1"><a class="header-anchor" href="#内部联结" aria-hidden="true">#</a> 内部联结</h2><p><strong>INNER JOIN（内连接,或等值连接）ON</strong>：获取两个表中字段匹配关系的记录。</p><p>目前为止所用的联结称为等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内部联结。其实，对于这种联结可以使用稍微不同的语法来明确指定联结的类型。</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>SELECT vend_name AS &quot;供应商&quot;,prod_name AS &quot;商品名&quot;,prod_price AS &quot;商品价格&quot;\nFROM vendors \nINNER JOIN products\nON vendors.vend_id = products.vend_id;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这里，两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。</p><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292229434.gif" alt="img"></p><p><strong>LEFT JOIN（左连接）</strong>：获取左表所有记录，即使右表没有对应匹配的记录。</p><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292229435.gif" alt="img"></p><p><strong>RIGHT JOIN（右连接）：</strong> 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</p><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292229436.gif" alt="img"></p><p><strong>使用哪种语法</strong>： ANSI SQL规范首选INNER JOIN语法。此外，尽管使用WHERE子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件，有时候这样做也能影响性能。</p><h2 id="联结多个表" tabindex="-1"><a class="header-anchor" href="#联结多个表" aria-hidden="true">#</a> 联结多个表</h2><p>SQL对一条SELECT语句中可以联结的表的数目没有限制。 创建联结的基本规则也相同：首先列出所有表，然后定义表之间的关系。</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>SELECT prod_name AS &quot;商品名&quot;,vend_name AS &quot;供应商&quot;,prod_price AS &quot;商品价格&quot;,quantity AS &quot;数量&quot;\nFROM products,vendors,orderitems\nWHERE products.vend_id = vendors.vend_id \nAND products.prod_id = orderitems.prod_id \nAND orderitems.order_num = 20005;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292229437.png" alt="image-20211020195548715"></p><p>这里的FROM子句列出了3个表，而WHERE子句定义了这两个联结条件，而第三个联结条件用来过滤出订单20005中的物品。</p><p><strong>性能考虑</strong> MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害。</p>',47),a={},t=(0,n(3744).Z)(a,[["render",function(e,s){return r}]])},3744:(e,s)=>{s.Z=(e,s)=>{const n=e.__vccOpts||e;for(const[e,r]of s)n[e]=r;return n}}}]);