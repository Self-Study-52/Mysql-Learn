"use strict";(self.webpackChunkMysql_Learn=self.webpackChunkMysql_Learn||[]).push([[218],{9139:(e,t,s)=>{s.r(t),s.d(t,{data:()=>d});const d={key:"v-72fdf4b2",path:"/guide/%E3%80%8AMysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE.html",title:"第十二章：分组数据",lang:"en-US",frontmatter:{title:"第十二章：分组数据",lang:"en-US"},excerpt:"",headers:[{level:2,title:"数据分组",slug:"数据分组",children:[]},{level:2,title:"创建分组数据",slug:"创建分组数据",children:[]},{level:2,title:"过滤分组",slug:"过滤分组",children:[]},{level:2,title:"分组和排序",slug:"分组和排序",children:[]},{level:2,title:"SELECT 子句顺序",slug:"select-子句顺序",children:[]}],filePathRelative:"guide/《Mysql必知必会》/第十二章：分组数据.md",git:{updatedTime:1635847604e3,contributors:[{name:"Sue-52",email:"1219243947@qq.com",commits:1}]}}},9426:(e,t,s)=>{s.r(t),s.d(t,{default:()=>a});const d=(0,s(6252).uE)('<h1 id="第十二章-分组数据" tabindex="-1"><a class="header-anchor" href="#第十二章-分组数据" aria-hidden="true">#</a> 第十二章：分组数据</h1><p>本章将介绍如何分组数据，以便能汇总表内容的子集。这涉及两个新SELECT语句子句，分别是GROUP BY子句和HAVING子句。</p><h2 id="数据分组" tabindex="-1"><a class="header-anchor" href="#数据分组" aria-hidden="true">#</a> 数据分组</h2><p>目前为止的所有计算都是在表的所有数据或匹配特定的WHERE子句的数据上进行的。</p><p>分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算</p><h2 id="创建分组数据" tabindex="-1"><a class="header-anchor" href="#创建分组数据" aria-hidden="true">#</a> 创建分组数据</h2><p>分组是在SELECT语句的<code>GROUP BY</code>子句中建立的。</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>select title,count(*) as production from houses group by title;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292228911.png" alt="image-20211018172139053"></p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>select entire ,count(*) as production from houses group by entire;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292228912.png" alt="image-20211018172223538"></p><p>将拥有相同值的数据总和到一起。</p><p>因为使用了GROUP BY，就不必指定要计算和估值的每个组了。系统会自动完成。GROUP BY子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集。</p><p>在具体使用GROUP BY子句前，需要知道一些重要的规定。</p><ul><li>GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。</li><li>如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li><li>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</li><li>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</li><li>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</li><li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</li></ul><blockquote><p><strong>使用ROLLUP</strong>: 使用<code>WITH ROLLUP</code>关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值.</p></blockquote><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>select entire ,count(*) as production from houses group by entire with rollup;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292228913.png" alt="image-20211018172730681"></p><h2 id="过滤分组" tabindex="-1"><a class="header-anchor" href="#过滤分组" aria-hidden="true">#</a> 过滤分组</h2><p>除了能用GROUP BY分组数据外，MySQL还允许过滤分组，规定包括哪些分组，排除哪些分组。</p><p><strong>HAVING支持所有WHERE操作符</strong> 我们学习了WHERE子句的条件（包括通配符条件和带多个操作符的子句）。所学过的有关WHERE的所有这些技术和选项都适用于HAVING。它们的句法是相同的，只是关键字有差别。</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>select entire ,count(*) as production from houses group by entire having count(*)&gt;5000;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292228914.png" alt="image-20211018173007059"></p><p><strong>HAVING和WHERE的差别</strong>： 这里有另一种理解方法，WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重要的区别，WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>select price_num,count(*) as production from houses where entire = 1 group by price_num having count(*)&gt;100;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>首先， <code>where</code> 过滤了所有 <code>entrie</code> 为 0 的数据， <code>group by</code> 将拥有相同价格的数据累加， <code>having</code> 将排列完的数据进一步的筛选</p><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292228915.png" alt="image-20211018174212703"></p><h2 id="分组和排序" tabindex="-1"><a class="header-anchor" href="#分组和排序" aria-hidden="true">#</a> 分组和排序</h2><p>虽然GROUP BY和ORDER BY经常完成相同的工作，但它们是非常不同的。</p><table><thead><tr><th>ORDER BY</th><th>GROUP BY</th></tr></thead><tbody><tr><td>排序产生的输出</td><td>分组行。但输出可能不是分组的顺序</td></tr><tr><td>任意列都可以使用（甚至非选择的列也可以）</td><td>只能使用选择列或表达式列，而且必须使用每个选项列表达式</td></tr><tr><td>不一定需要</td><td>如果与聚集函数一起使用（或表达式）则必须使用</td></tr></tbody></table><p>不要忘记 <code>ORDER BY</code> 一般在使用<code>GROUP BY</code>子句时，应该也给出<code>ORDER BY</code>子句。这是保证数据正确排序的唯一方法。千万不要仅依赖<code>GROUP BY</code>排序数据。</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>select id,title,price_num * `size` as price from houses group by id having title order by price; \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><img src="https://gitee.com/sue201982/mysql/raw/master/img/202110292228916.png" alt="image-20211018180652544"></p><h2 id="select-子句顺序" tabindex="-1"><a class="header-anchor" href="#select-子句顺序" aria-hidden="true">#</a> SELECT 子句顺序</h2><p>SELECT语句中使用时必须遵循的次序，列出迄今为止所学过的子句。</p><p align="center">SELECT子句及顺序</p><table><thead><tr><th>子句</th><th>描述</th><th>是否必须使用</th></tr></thead><tbody><tr><td>SELECT</td><td>要返回的列或表达式</td><td>是</td></tr><tr><td>FROM</td><td>从中检索数据的表</td><td>仅在从表选择数据时使用</td></tr><tr><td>WHERE</td><td>行级过滤</td><td>否</td></tr><tr><td>GROUP BY</td><td>分组说明</td><td>仅在从表选择数据时使用</td></tr><tr><td>HAVING</td><td>组级过滤</td><td>否</td></tr><tr><td>ORDER BY</td><td>输出顺序排序</td><td>否</td></tr><tr><td>LIMIT</td><td>要检索的行数</td><td>否</td></tr></tbody></table>',37),r={},a=(0,s(3744).Z)(r,[["render",function(e,t){return d}]])},3744:(e,t)=>{t.Z=(e,t)=>{const s=e.__vccOpts||e;for(const[e,d]of t)s[e]=d;return s}}}]);