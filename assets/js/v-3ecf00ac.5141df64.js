"use strict";(self.webpackChunkMysql_Learn=self.webpackChunkMysql_Learn||[]).push([[536],{3655:(e,l,s)=>{s.r(l),s.d(l,{data:()=>n});const n={key:"v-3ecf00ac",path:"/guide/%E3%80%8AMysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86.html",title:"第二十四章：管理事务处理",lang:"en-US",frontmatter:{title:"第二十四章：管理事务处理",lang:"en-US"},excerpt:"",headers:[{level:2,title:"控制事务处理",slug:"控制事务处理",children:[{level:3,title:"使用 ROLLBACK",slug:"使用-rollback",children:[]},{level:3,title:"使用 COMMIT",slug:"使用-commit",children:[]},{level:3,title:"使用保留点 SAVEPOINT",slug:"使用保留点-savepoint",children:[]},{level:3,title:"更改默认的提交行为",slug:"更改默认的提交行为",children:[]}]}],filePathRelative:"guide/《Mysql必知必会》/第二十四章：管理事务处理.md",git:{updatedTime:1635847604e3,contributors:[{name:"Sue-52",email:"1219243947@qq.com",commits:1}]}}},930:(e,l,s)=>{s.r(l),s.d(l,{default:()=>i});const n=(0,s(6252).uE)('<h1 id="第二十四章-管理事务处理" tabindex="-1"><a class="header-anchor" href="#第二十四章-管理事务处理" aria-hidden="true">#</a> 第二十四章：管理事务处理</h1><p>并非所有的数据库引擎都支持事务处理管理。<code>MyISAM</code> 和 <code>InnoDB</code> 前者不支持明确的事务处理管理，后者支持。</p><p>事务处理（transaction processing）：可以用来维护数据库的完整性，它保证了成批的Mysql操作要么完全执行，要么完全不执行。<strong>良好的数据库设计模式都是关联的。</strong></p><p><strong>Ex：添加订单：</strong></p><ol><li>检查数据库中是否有相应的客户，如果不存在则添加。</li><li>检索客户的ID</li><li>添加一行到订单表，并把它和客户ID关联</li><li>检索订单表中赋予的新订单ID</li><li>对于订单的每个商品在订单商品表中添加一行，通过检索出来的ID把它和订单表关联</li></ol><p>但是，某种原因数据库故障了（如：超出磁盘空间、安全限制、表锁等）阻止了过程的完成，会怎样呢？</p><p>如果故障发生在添加了客户之后，订单表添加之前，不会有什么问题。某些客户没有订单是完全合法的。在重新执行此过程时，所插入的客户记录将被检索和使用。可以有效地从出故障的地方开始执行此过程。</p><p>但是，如果故障发生在订单行添加之后，订单商品行添加之前，怎么办呢？现在，数据库中有一个空订单。</p><p>更糟的是，如果系统在添加订单商品行之中出现故障。结果是数据库中存在不完整的订单，而且你还不知道。</p><p>这时候就需要<strong>事务处理</strong>，它是一种机制，用来管理必须成批执行的Mysql操作，以保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。</p><p>相同的例子，如何工作：</p><ol><li>检查数据库中是否存在相应的客户，如果不存在，添加他/她。</li><li>提交客户信息。</li><li>检索客户的ID。</li><li>添加一行到订单表。</li><li>如果在添加行到订单表时出现故障，回退</li><li>检索订单表中赋予的新订单ID。</li><li>对于订购的每项物品，添加新行到订单商品表。</li><li>如果在添加新行到订单商品时出现故障，回退所有添加的订单商品行和订单行。</li><li>提交订单信息。</li></ol><p>专业术语：</p><ul><li>事务（transaction）：指一组SQL语句</li><li>回退（rollback）：指撤销指定SQL语句的过程</li><li>提交（commmit）：指将为存储的SQL语句将结果写入数据库表</li><li>保留点（savepoint）：指事务处理中设置的临时占位符（placeholder），你可以对它发布退回（与退回整个事务处理不同）。</li></ul><h2 id="控制事务处理" tabindex="-1"><a class="header-anchor" href="#控制事务处理" aria-hidden="true">#</a> 控制事务处理</h2><p>管理事务处理的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。</p><p>一般来说，事务必须满足4个条件（ACID）：</p><ul><li>原子性（Atmoicity 不可分割性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被滚回（rollback）到事务开始前的状态，就像这个事务没有执行过一样。</li><li>一致性（Consistency）：在事务开始之前和事务结束后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定功能工作</li><li>隔离性（Isolation 独立性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括了读未提交（Read uncommitted）、读提交（Read committed）、可重复读（Repeatable Read）和串行化（Serializable）。</li><li>持久性（Durability）：事务处理结束后，对数据修改就是永久的，即使系统故障也不会丢失。</li></ul><p>开始标识事务语句：</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>START TRANSACTION;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="使用-rollback" tabindex="-1"><a class="header-anchor" href="#使用-rollback" aria-hidden="true">#</a> 使用 ROLLBACK</h3><p>Mysql 的 ROLLBACK 命令用来回退（撤销）Mysql语句。</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>SELECT * FROM products; -- 选择所有商品\nSTART TRANSACTION; -- 开启事务处理\nDELETE FROM products WHERE prod_id =&#39;XCE05&#39;; -- 删除\nSELECT * FROM products; -- 查看：空\nROLLBACK; -- 退回\nSELECT * FROM products; -- 查看：还原了数据\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>显然，ROLLBACK 只能在一个事务处理内使用（（在执行一条START TRANSACTION命令之后）。</p><blockquote><p>那些语句可以退回：事务处理用来管理 INSERT、UPDATE、DELETE语句。无法退回SELECT语句（没有意义），也不能退回CREATE和DROP操作。事务处理块中可以使用，但是如果执行退回，它们不会被撤销。</p></blockquote><h3 id="使用-commit" tabindex="-1"><a class="header-anchor" href="#使用-commit" aria-hidden="true">#</a> 使用 COMMIT</h3><p>Mysql的语句都是直接针对数据库表执行和编写的。这就是所谓的<code>隐含提交（implicit commit）</code>，即提交（写或保存）操作都是自动进行的。</p><p>但是，在事务处理中，提交不会隐含的进行。为了进行明确的提交，使用 <code>COMMIT</code> 语句。</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>START TRANSACTION;\nDELETE FROM orderitems WHERE order_num = 20010;\nDELETE FROM orders WHERE order_num = 20010;\nCOMMIT;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在这个例子中，从系统中完全删除订单20010。因为涉及更新两个数据库表orders和orderItems，所以使用事务处理块来保证订单不被部分删除。最后的COMMIT语句仅在不出错时写出更改。如果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，它是被自动撤销的）。</p><blockquote><p>隐含事务关闭：当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）</p></blockquote><h3 id="使用保留点-savepoint" tabindex="-1"><a class="header-anchor" href="#使用保留点-savepoint" aria-hidden="true">#</a> 使用保留点 SAVEPOINT</h3><p>简单的ROLLBACK和COMMIT语句就可以写入或撤销整个事务处理。但是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要部分提交或回退。</p><p>例如，前面描述的添加订单的过程为一个事务处理。如果发生错误，只需要返回到添加orders行之前即可，不需要回退到customers表（如果存在的话）。</p><p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符。这样，如果需要回退，可以回退到某个占位符。</p><p>这些占位符称为保留点。为了创建占位符，可如下使用SAVEPOINT语句：</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>SAVEPOINT identifier;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>删除保留点：</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>RELEASE SAVEPOINT identifier;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>将事务回滚到标记点：</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>ROLLBACK TO identifier\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>每个保留点都要取标识它唯一的名字，以便在退回时，Mysql知道要退回到哪里。</p><blockquote><p><strong>保留点越多越好</strong> 可以在MySQL代码中设置任意多的保留点，越多越好。为什么呢？因为保留点越多，你就越能按自己的意愿灵活地进行回退. <strong>释放保留点</strong> 保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。</p></blockquote><h3 id="更改默认的提交行为" tabindex="-1"><a class="header-anchor" href="#更改默认的提交行为" aria-hidden="true">#</a> 更改默认的提交行为</h3><p>默认的Mysql行为时自动提交所有更改。换句话说，任何时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句：</p><p>SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code>SET AUTOCOMMIT = 0; -- 禁止自动提交\nSET AUTOCOMMIT = 1; -- 开启自动提交\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>autocommit</code> 标志决定是否自动提交更改，不管有没有 COMMIT 语句。</p><blockquote><p><strong>标志为连接专用</strong>：autocommit 标志是针对每个连接而不是服务器。</p></blockquote>',49),a={},i=(0,s(3744).Z)(a,[["render",function(e,l){return n}]])},3744:(e,l)=>{l.Z=(e,l)=>{const s=e.__vccOpts||e;for(const[e,n]of l)s[e]=n;return s}}}]);