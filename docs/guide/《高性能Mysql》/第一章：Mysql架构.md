---
title: 第一章：Mysql架构
lang: en-US
---

# 第一章：Mysql架构

Mysql 的架构可以在不同的场景中应用并发挥的很好且很灵活；能适应不同的使用环境。同时，Mysql可以嵌入到应用系统中，也可以支持数据仓库、内容索引和部署软件、高可用的冗余系统、在线事务处理系统（OLTP）等应用。

Mysql最重要、最与众不同的特性是它的存储引擎架构，这种加架构的设计将查询处理（Query Processing）及其他系统任务（Server Task）和数据的存储、提取相分离。这种处理和存储分离设计可以在使用时根据性能、特性、以及其他需求来选择数据存储的方式。

## 1.1 MySQL 逻辑架构

**<p align='center'>MySQL 服务器逻辑架构图</p>**

![img](https://gitee.com/sue201982/mysql/raw/master/img/202111031053989.png)

最上层的服务：

大多数基于网络的客户端/服务端的工具或者服务都有类似的架构。连接处理、授权认证、安全等

- Connection Pool : 连接池组件

第二层的服务：

主要以Mysql的核心服务功能包括了查询解析、分析、优化、缓存以及所有的内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

- Management Services & Utilities : 管理服务和工具组件
- SQL Interface : SQL接口组件
- Parser : 查询分析器组件
- Optimizer : 优化器组件
- Caches & Buffers : 缓冲池组件

第三层的服务：

存储引擎负责MySQL中数据的存储和提取。和 GNU/Limux 下的各种文件系统一样，每个存储引擎都有它的优势和劣势。服务器通过 API 与存储引擎进行通信。这谢谢结构屏蔽了不同存储引擎之间的差异，使得这差异对上层查村过程透明。存储引擎 API 包含了几十个底层函数，用于执行诸如 “开始一个事务” 或 “根据主键提取一行数据” 等操作。但存储引擎不回去解析SSQL，不同存储引擎也不会相互通信，而只是简单地响应上层服务器的请求。

Mysql5.5之后的版本提供了一个API，支持线程池（Thread-Pooling）插件，可以使用池中少量的线程来服务大量的连接。

- Pluggable Storage Engines : 存储引擎
- File System : 文件系统

### 1.1.1 连接管理与安全性

每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或CPU中运行。服务器会负责缓存线程，因此不需要为每个新建的连接创建或销毁线程。

当客户端（应用）连接到Mysql服务器时，服务器需要对其进行认证。认证基于用户名、原始主机信息和密码。如果使用安全套接字（SSL）的方式连接，还可以使用哦个 X.509 整数认证。一旦客户端连接成功，服务器就会继续验证该客户端是否具有执行某个特定查询的全新先。

### 1.1.2 优化与执行

Mysql 会解析查询寻，并创建内部数据结构（解析树），然后对其优化，包括重写查询、决定表的读取顺序、以及和合适的索引等。用户通过特殊的关键字提示（hint）优化器，影响其决策过程。也可以请求优化器解释（explain）优化过长城的各种因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构查询和schema、修改相关配置提高运行效率。

优化器不在乎什么存储引擎，但是存储引擎会影响优化查询。优化器请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。

对于 SELECT 语句，在解析查询之前，服务器会先检查查询缓存（Query Cache），如果找到对应语句，服务器则不会执行查询解析、优化和执行整个过程，而是直接返回查询缓存中的结果。

## 1.2 并发控制

只要有多个查询在同一时间进行修改数据，就会产生**并发**控制的问题。以两个层面的方式考虑并发控制的问题：

- 服务器层
- 存储引擎层

### 1.2.1 读写锁

问题：

当同一时刻多个用户并发读取邮箱信息，但是某个客户正在读取邮件，同时另一个用户视图删除该邮件，会怎样？读取邮件的客户可能会报错从而退出，也可能读到不一致的邮箱数据。

如果解决：

在处理并发读或写时，可以通过实现一个有两种类型的锁组成的锁系统来解决问题。通常称为：

- 共享锁（shared lock）
- 排他锁（exclusive lock）

也叫：

- 读锁（read lock）
- 写锁（write lock）

概念为：

读锁为共享的，或者说互不阻塞的。多个用户在同一时刻可以同时读取同一个资源，而互不干扰。

写锁为排他的，也就是说一个写锁回阻塞去他的写锁和读锁，这是出于安全策略的考虑，只有这样才能确保在给定时间里，只有一个用户执行写入操作，并防止其他用户读取正在写入的资源。

在Mysql中锁的内部管理都是透明的。

### 1.2.2 锁粒度

一种提高共享资源并发性的方式就是让锁定对象更具有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式为，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要互相之间不发生冲突即可。

但是加锁的也会消耗资源。锁的操作：获得锁、检查锁是否已经解除、释放锁等。都会增加系统的开销。如果消耗大量时间管理锁的而不是存取数据，系统性能会因此受到影响。

所谓的锁策略，就是锁的开销和安全性之间寻求平衡，这种平衡会影响性能。大多数商业数据库系统没有提供更多选择，一般都是在表上施加行级锁（row-level lock）。

Mysql提供了多种选择。每个存储引擎都可以实现自己的锁策略和锁粒度。

**<font size=5>表锁（table lock）</font>**

表锁是 MySQL 中最基本的锁策略，并且是开销最小的策略。类似于之前描述的邮箱加锁机制：它会锁定整张表。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间不相互阻塞的。

例如：

Read Local 表锁支持某些类型的并发操作。另外，写锁也比读锁有更高的优先级，因此一个写锁请求可能被插入到读锁队列的前面。

尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。Ex：服务器会为诸如ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。

**<font size=5>行级锁（row lock）</font>**

行级锁可以最大程度的支持并发处理（同时也是开销最大的锁）。在InnoDB中实现了。行级锁只在存储引擎层实现，而Mysql服务器层没有。因为服务器曾完全不了解存储引擎中锁实现。

## 1.3 事务

事务就是一组原子性的SQL查询，或是一个独立的工作单元。

- **原子性（Atmoicity 不可分割性）**：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被滚回（rollback）到事务开始前的状态，就像这个事务没有执行过一样。
- **一致性（Consistency）**：在事务开始之前和事务结束后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定功能工作
- **隔离性（Isolation 独立性）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括了读未提交（Read uncommitted）、读提交（Read committed）、可重复读（Repeatable Read）和串行化（Serializable）。
- **持久性（Durability）**：事务处理结束后，对数据修改就是永久的，即使系统故障也不会丢失。

事物的ACID可以确保事务可以成功执行而不会让数据丢失。而在应用逻辑中，要实现起来十分困难。一个兼容ACID的数据库系统，需要很多复杂但可能用户并没有察觉到的工作，才能确保ACID的实现。

和锁粒度类似，升级会增加系统开销一样，这种事务处理过程额外的安全性，也会需要数据库做更多的额外工作。

一个实现了ACID的数据库，相比没有实现ACID的数据库通常拥有更强大的CPU处理能力、更大的内存和更多的磁盘空间。根据不同的业务使用不同的存储引擎，以便提高性能。即使一些非事务型的存储引擎也可以通过 LOCK TABLES 提供一定的保护。

### 1.3.1 隔离级别（Isolation level）

SQL标准定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，那些在事务内和事务间可见的，那些不可见。较低级别的隔离通常可以执行更高的并发，系统开销更低。

隔离级别分类：

- **READ UNCOMMITTED（未提交读）**：事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，为被称为**脏读（Dirty Read）**。这个级别会导致很多问题，从性能上来说，Read Uncommitted 不会比其他级别好太多，并且缺乏其他级别的很多优势，一般很少用这个。
- **READ COMMITTED（提交读）**：大部分数据库系统默认隔离级别都是 READ COMMITTED（Mysql不是）。Read Committed满足前面提到的隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话来说，一个事务从开始直到提交之前，所做的任何修改对其他事务都不可见的。这个级别有时候也叫做**不可重复读（nonrepeatable read）**，因此两次执行同样的查询，可能会得到不一样的结果。
- **REPEATABLE READ（可重复读）**：REPEATABLE READ解决了脏读的问题。该级别保证了同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复隔离界别还是无法解决另外一个问题：**幻读（Phantom Read）**。所谓幻读，指的是当某个事物在读取某个范围的记录时，会产生**幻行（Phantom Row）**。多数的存储引擎通过版本并发控制（MVCC，Multi Version Concurrency Control）解决了这个问题。**可重复读是Mysql的默认事务隔离级别**
- **SERIALIZABLE（可串行化）**：SERIALIZABLE为最高隔离级别。其通过强制事务串行执行，避免了幻读问题。简单的来说，SERIALIZABLE会在读取每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用很少用这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。

**<p algin="center">ANSI SQL 隔离级别</p>**

|     隔离级别     | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| :--------------: | :--------: | :--------------: | :--------: | :----: |
| READ UNCOMMITTED |    Yes     |       Yes        |    Yes     |   No   |
|  READ COMMITTED  |     No     |       Yes        |    Yes     |   No   |
| REPEATABLE READ  |     No     |        No        |    Yes     |   No   |
|   SERIALIZABLE   |     No     |        No        |     No     |  Yes   |

### 1.3.2 死锁

定义：

指的是两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

当事务试图以不同的顺序锁定资源时，就会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。

Ex：

事务一：

~~~mysql
START TRANSACTION;
UPDATE StockPrice SET close = 45.50 WHERE store_id = 4 AND date = '2001-05-01';
UPDATE StockPrice SET close = 19.80 WHERE store_id = 3 AND date = '2001-05-02';
COMMIT;
~~~

事务二：

~~~mysql
START TRANSACTION;
UPDATE StockPrice SET close = 20.12 WHERE store_id = 3 AND date = '2001-05-02';
UPDATE StockPrice SET close = 47.20 WHERE store_id = 4 AND date = '2001-05-01';
COMMIT;
~~~

如果凑巧，两个事务都执行了第一条UPDATE语句，更新了一行数据，同时也锁定了该行数据，接着每个事务都尝试去执行第二条UPDATE语句，却发现该行已经被对方锁定，然后两个事务都等待对方释放锁，同时又持有对方需要的锁，则陷入死循环。除非有外部因素介入才能解除死锁。

为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，如InnoDB存储引擎，越能检测到死锁的循环依赖，并立刻返回一个错误机制。这种解决方法很有效，否则死锁会导致出现查询过慢。另一种方法解决，就是在查询时达到锁等待超时的设定后放弃锁请求。InnoDB处理方法为：将持有最少行级排他锁的事务进行滚回。

锁的行为和存储引擎有关，同样的语句在不同的存储引擎会产生死锁，有的不会；原因：要么是数据冲突，要么是存储引擎的实现方式导致的。

死锁发生后，只有部分或完全回滚其中一个事务才能打破死锁。这是事务型系统无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。

### 1.3.3 事务日志

